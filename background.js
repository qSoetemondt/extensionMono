// D√©tecter le navigateur et utiliser l'API appropri√©e
function getBrowserAPI() {
  if (typeof chrome !== 'undefined' && chrome.runtime) {
    return chrome;
  } else if (typeof browser !== 'undefined' && browser.runtime) {
    return browser;
  }
  throw new Error('Extension API not available');
}

const browserAPI = getBrowserAPI();

// V√©rifier que l'API est disponible
console.log('[Background] Browser API d√©tect√©:', {
  hasRuntime: !!browserAPI.runtime,
  hasStorage: !!browserAPI.storage,
  hasTabs: !!browserAPI.tabs,
  hasNotifications: !!browserAPI.notifications
});

// Configuration par d√©faut
const TWITCH_USERNAME = 'monodie';
const TWITCH_URL = `https://www.twitch.tv/${TWITCH_USERNAME}`;

// Variables globales
let isLive = false;
let checkInterval = null;
let liveTabId = null;
let messageTimeout = null;
let ircSocket = null;
let ircConnected = false;

const CHECK_INTERVAL_MS = 60000; // V√©rifier toutes les minutes

// Initialisation pour Chrome Service Worker
if ('serviceWorker' in navigator || typeof browserAPI.action !== 'undefined') {
  // Service Worker Chrome
  console.log('[Background] üöÄ Service Worker initialis√© (Chrome)');
  loadSettings().then(() => {
    startMonitoring();
  });
} else {
  // Background Script Firefox
  console.log('[Background] üöÄ Background Script initialis√© (Firefox)');
  loadSettings();
  startMonitoring();
}

// √âcouter l'activation du service worker (Chrome)
browserAPI.runtime.onInstalled.addListener(() => {
  console.log('[Background] ‚úÖ Extension Twitch Live Notifier install√©e');
  loadSettings().then(() => {
    startMonitoring();
  });
});

// R√©activer au d√©marrage pour les service workers Chrome
browserAPI.runtime.onStartup?.addListener(() => {
  console.log('[Background] üöÄ Service Worker d√©marr√©');
  loadSettings().then(() => {
    startMonitoring();
  });
});

// Charger les param√®tres depuis le storage
async function loadSettings() {
  try {
    let result = await browserAPI.storage.local.get([
      'autoOpen',
      'muted',
      'autoMessages',
      'messages',
      'minInterval',
      'maxInterval'
    ]);
    
    // V√©rifier que result existe
    if (!result || typeof result !== 'object') {
      console.log('[Background] Aucune configuration trouv√©e, utilisation des valeurs par d√©faut');
      result = {};
    }
    
    // Valeurs par d√©faut
    if (!result.autoOpen) {
      await browserAPI.storage.local.set({ autoOpen: true });
    }
    if (!result.muted) {
      await browserAPI.storage.local.set({ muted: true });
    }
    if (!result.autoMessages && result.autoMessages !== false) {
      await browserAPI.storage.local.set({ autoMessages: true });
    }
    if (!result.messages || result.messages.length === 0) {
      const defaultMessages = [
        "Salut ! üëã",
        "Super live comme toujours !",
        "Continue comme √ßa !",
        "Tu g√®res ! üî•"
      ];
      await browserAPI.storage.local.set({ messages: defaultMessages });
    }
    if (!result.minInterval) {
      await browserAPI.storage.local.set({ minInterval: 15 }); // 15 minutes par d√©faut
    }
    if (!result.maxInterval) {
      await browserAPI.storage.local.set({ maxInterval: 40 }); // 40 minutes par d√©faut
    }
  } catch (error) {
    console.error('[Background] Erreur lors du chargement des param√®tres:', error);
  }
}

// D√©marrer la surveillance
async function startMonitoring() {
  if (checkInterval) {
    clearInterval(checkInterval);
  }
  
  console.log('[Background] üöÄ D√©marrage de la surveillance...');
  
  checkInterval = setInterval(checkLiveStatus, CHECK_INTERVAL_MS);
  
  // V√©rifier imm√©diatement
  await checkLiveStatus();
}

// Arr√™ter la surveillance
function stopMonitoring() {
  if (checkInterval) {
    clearInterval(checkInterval);
    checkInterval = null;
  }
}

// V√©rifier le statut du live
async function checkLiveStatus() {
  try {
    console.log(`[Background] V√©rification du live pour ${TWITCH_USERNAME}...`);
    
    // Utiliser l'API Twitch pour v√©rifier le statut du live
    // Note: decapi.me retourne du texte simple, pas du JSON
    const response = await fetch(`https://decapi.me/twitch/uptime/${TWITCH_USERNAME}`);
    const data = await response.text(); // Utiliser .text() au lieu de .json()
    
    console.log(`[Background] R√©ponse de l'API:`, data);
    
    const wasLive = isLive;
    
    // D√©tecter si c'est en live (l'API retourne "offline", "not found" ou une dur√©e de live)
    isLive = (data !== 'offline' && 
              data !== 'not found' && 
              data !== null && 
              typeof data === 'string' && 
              data.length > 0 &&
              data !== '');
    
    console.log(`[Background] Statut live: ${isLive} (ancien: ${wasLive})`);
    
    if (isLive && !wasLive) {
      // Le live vient de commencer
      console.log('[Background] ‚úÖ Live d√©tect√© !');
      await handleLiveStart();
    } else if (!isLive && wasLive) {
      // Le live s'est arr√™t√©
      console.log('[Background] ‚ö™ Live termin√©');
      stopMessageInterval();
    } else if (isLive) {
      console.log('[Background] üî¥ Toujours en live');
    } else {
      console.log('[Background] ‚ö™ Pas en live actuellement');
    }
  } catch (error) {
    console.error('[Background] Erreur lors de la v√©rification du live:', error);
  }
}

// G√©rer le d√©but du live
async function handleLiveStart() {
  try {
    const settings = await browserAPI.storage.local.get(['autoOpen', 'muted']);
    
    // Valeurs par d√©faut si settings est undefined
    const autoOpen = settings?.autoOpen !== false;
    const muted = settings?.muted !== false;
    
    console.log('[Background] Settings:', { autoOpen, muted });
    
    // Envoyer une notification
    browserAPI.notifications.create({
      type: 'basic',
      iconUrl: 'icons/icon48.png',
      title: 'üé¨ Live d√©marr√© !',
      message: `${TWITCH_USERNAME} est en live sur Twitch !`,
      priority: 2
    });
    
    // Ouvrir le live dans un onglet si activ√©
    if (autoOpen && browserAPI.tabs && browserAPI.tabs.create) {
      try {
        browserAPI.tabs.create({
          url: TWITCH_URL,
          active: false,
          pinned: false
        }).then(tab => {
          liveTabId = tab.id;
          
          console.log('[Background] Onglet cr√©√©:', liveTabId);
          
          // Muter l'onglet si demand√©
          if (muted && browserAPI.tabs && browserAPI.tabs.update) {
            browserAPI.tabs.update(liveTabId, { muted: true }).catch(err => {
              console.error('[Background] Erreur lors du mute:', err);
            });
          }
          
          // Connecter IRC et d√©marrer l'envoi de messages
          connectIRC().then(() => {
            startMessageInterval();
          });
        }).catch(err => {
          console.error('[Background] Erreur lors de la cr√©ation de l\'onglet:', err);
        });
      } catch (err) {
        console.error('[Background] Erreur tabs.create:', err);
      }
    } else {
      console.warn('[Background] tabs.create non disponible');
      // Connecter IRC et d√©marrer quand m√™me les messages
      connectIRC().then(() => {
        startMessageInterval();
      });
    }
  } catch (error) {
    console.error('[Background] Erreur lors de handleLiveStart:', error);
  }
}

// G√©n√©rer un temps al√©atoire en millisecondes
function getRandomTime(minMinutes, maxMinutes) {
  const minMs = minMinutes * 60000;
  const maxMs = maxMinutes * 60000;
  return Math.floor(Math.random() * (maxMs - minMs + 1)) + minMs;
}

// D√©marrer l'envoi de messages automatique avec temps al√©atoire
function startMessageInterval() {
  if (messageTimeout) {
    clearTimeout(messageTimeout);
  }
  
  scheduleNextMessage();
}

// Programmer le prochain message avec un temps al√©atoire
function scheduleNextMessage() {
  browserAPI.storage.local.get(['messages', 'minInterval', 'maxInterval']).then(result => {
    if (!result.messages || result.messages.length === 0) {
      console.log('[Background] Aucun message configur√©');
      return;
    }
    
    const minInterval = result.minInterval || 15; // 15 minutes par d√©faut
    const maxInterval = result.maxInterval || 40; // 40 minutes par d√©faut
    
    const randomTime = getRandomTime(minInterval, maxInterval);
    
    console.log(`[Background] Prochain message dans ${Math.round(randomTime / 60000)} minutes`);
    
    // Programmer le message
    messageTimeout = setTimeout(() => {
      sendRandomMessage();
      scheduleNextMessage(); // Programmer le message suivant
    }, randomTime);
  });
}

// Arr√™ter l'envoi de messages
function stopMessageInterval() {
  if (messageTimeout) {
    clearTimeout(messageTimeout);
    messageTimeout = null;
  }
  
  // Fermer la connexion IRC si elle existe
  if (ircSocket) {
    ircSocket.close();
    ircSocket = null;
    ircConnected = false;
  }
}

// Envoyer un message al√©atoire via IRC
async function sendRandomMessage() {
  const result = await browserAPI.storage.local.get(['messages', 'twitch_access_token', 'autoMessages']);
  
  // V√©rifier si l'envoi automatique est activ√©
  if (result.autoMessages === false) {
    console.log('[Background] Envoi automatique de messages d√©sactiv√©');
    return;
  }
  
  if (!result.messages || result.messages.length === 0) {
    console.log('[Background] Aucun message configur√©');
    return;
  }
  
  if (!result.twitch_access_token) {
    console.warn('[Background] Pas de token OAuth, impossible d\'envoyer via IRC');
    return;
  }
  
  const messages = result.messages;
  const randomMessage = messages[Math.floor(Math.random() * messages.length)];
  
  console.log('[Background] üì§ Envoi du message via IRC:', randomMessage);
  
  try {
    // Envoyer via IRC Twitch
    await sendMessageViaIRC(TWITCH_USERNAME, randomMessage);
    console.log('[Background] ‚úÖ Message envoy√© via IRC');
  } catch (error) {
    console.error('[Background] Erreur envoi IRC:', error);
  }
}

// Fonction pour maintenir une connexion IRC persistante
async function connectIRC() {
  const result = await browserAPI.storage.local.get(['twitch_access_token', 'twitch_username']);
  
  if (!result.twitch_access_token) {
    console.error('[IRC] Pas de token OAuth disponible');
    return;
  }
  
  // R√©cup√©rer le nom d'utilisateur depuis le token ou les param√®tres
  const username = result.twitch_username || TWITCH_USERNAME;
  
  // Fermer l'ancienne connexion si elle existe
  if (ircSocket) {
    ircSocket.close();
  }
  
  ircSocket = new WebSocket('wss://irc-ws.chat.twitch.tv:443');
  
  ircSocket.onopen = () => {
    console.log('[IRC] Connexion WebSocket √©tablie');
    
    // Authentifier
    ircSocket.send(`PASS oauth:${result.twitch_access_token}`);
    ircSocket.send(`NICK ${username}`);
    
    // Joindre le channel
    setTimeout(() => {
      ircSocket.send(`JOIN #${TWITCH_USERNAME}`);
      console.log(`[IRC] Rejoint #${TWITCH_USERNAME}`);
    }, 500);
  };
  
  ircSocket.onmessage = (event) => {
    const data = event.data;
    
    // R√©pondre au PING
    if (data.startsWith('PING')) {
      ircSocket.send('PONG :tmi.twitch.tv');
      console.log('[IRC] PONG envoy√©');
    }
    
    // D√©tecter quand on est connect√©
    if (data.includes('001') || data.includes(':tmi.twitch.tv 001')) {
      ircConnected = true;
      console.log('[IRC] ‚úÖ Authentifi√© et connect√©');
    }
    
    // V√©rifier si on a rejoint le channel
    if (data.includes(`:${username}!`) && data.includes(`JOIN #${TWITCH_USERNAME}`)) {
      console.log(`[IRC] ‚úÖ Rejoint #${TWITCH_USERNAME}`);
    }
  };
  
  ircSocket.onerror = (error) => {
    console.error('[IRC] Erreur:', error);
    ircConnected = false;
  };
  
  ircSocket.onclose = () => {
    console.log('[IRC] Connexion ferm√©e');
    ircConnected = false;
    
    // Tentative de reconnexion apr√®s 5 secondes si on est toujours en live
    if (isLive) {
      setTimeout(() => {
        console.log('[IRC] Tentative de reconnexion...');
        connectIRC();
      }, 5000);
    }
  };
}

// Fonction pour envoyer un message via IRC
async function sendMessageViaIRC(channel, message) {
  if (!ircSocket || !ircConnected) {
    console.log('[IRC] Connexion non pr√™te, connexion...');
    await connectIRC();
    
    // Attendre que la connexion soit pr√™te
    let attempts = 0;
    while (!ircConnected && attempts < 20) {
      await new Promise(resolve => setTimeout(resolve, 500));
      attempts++;
    }
    
    if (!ircConnected) {
      throw new Error('Impossible de se connecter √† IRC');
    }
  }
  
  // Envoyer le message
  ircSocket.send(`PRIVMSG #${channel} :${message}`);
  console.log(`[IRC] Message envoy√© sur #${channel}: ${message}`);
}

// Fonction de test pour forcer l'envoi d'un message
// Exposer dans l'API globale pour √™tre accessible depuis la console
try {
  if (typeof self !== 'undefined') {
    self.testSendMessage = function() {
      console.log('[Background] üß™ Test d\'envoi de message...');
      sendRandomMessage();
    };
  }
} catch(e) {
  console.log('[Background] Pas de self disponible');
}

// Alternative : exposer via une fonction globale
globalThis.testSendMessage = function() {
  console.log('[Background] üß™ Test d\'envoi de message...');
  sendRandomMessage();
};

console.log('[Background] üí° Fonction de test disponible: testSendMessage()');

// √âcouter les messages depuis le popup
browserAPI.runtime.onMessage.addListener((request, sender, sendResponse) => {
  console.log('[Background] Message re√ßu:', request);
  
  if (request.action === 'checkStatus') {
    console.log(`[Background] Statut demand√©, isLive=${isLive}`);
    sendResponse({ isLive });
    return true; // Important pour Firefox async responses
  } else if (request.action === 'startMonitoring') {
    startMonitoring();
    sendResponse({ success: true });
    return true;
  } else if (request.action === 'stopMonitoring') {
    stopMonitoring();
    sendResponse({ success: true });
    return true;
  } else if (request.action === 'toggleMute') {
    if (liveTabId) {
      browserAPI.tabs.get(liveTabId).then(tab => {
        browserAPI.tabs.update(liveTabId, { muted: !tab.mutedInfo.muted });
      });
    }
    sendResponse({ success: true });
    return true;
  } else if (request.type === 'OAUTH_TOKEN_RECEIVED') {
    // Sauvegarder le token re√ßu
    browserAPI.storage.local.set({
      twitch_access_token: request.token
    });
    console.log('[Background] ‚úÖ Token OAuth re√ßu et sauvegard√©');
    sendResponse({ success: true });
    return true;
  }
});

// Nettoyer lors de la d√©sinstallation
browserAPI.runtime.onSuspend.addListener(() => {
  stopMonitoring();
  stopMessageInterval();
});

// R√©initialiser le timer du message si les param√®tres changent
browserAPI.storage.onChanged.addListener((changes, areaName) => {
  if (areaName === 'local' && (changes.minInterval || changes.maxInterval)) {
    // Si un message est d√©j√† programm√©, le relancer avec les nouveaux param√®tres
    if (messageTimeout) {
      stopMessageInterval();
      if (isLive) {
        startMessageInterval();
      }
    }
  }
  
  // Si le token change et que IRC est connect√©, reconnecter
  if (changes.twitch_access_token && ircSocket) {
    console.log('[Background] Token chang√©, reconnexion IRC...');
    stopMessageInterval();
    if (isLive) {
      connectIRC().then(() => {
        startMessageInterval();
      });
    }
  }
});

